// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package errors

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
	runtime "runtime"
	strconv "strconv"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

var ERRORMessageMap = map[int32]string{
	0:         "",
	10000001:  "参数校验错误",
	10000002:  "未处理错误",
	10010003:  "认证错误",
	100000001: "oh missing",
	100000002: "oh error",
	10020001:  "query db error from sql-fx plugin",
	10020002:  "query db's injection is not implemented",
	10020003:  "query args not found",
}

var ERRORHttpCodeMap = map[int32]int{
	0:         200,
	10000001:  400,
	10000002:  404,
	10010003:  401,
	100000001: 400,
	100000002: 401,
	10020001:  500,
	10020002:  500,
	10020003:  500,
}

func (e ERROR) stackTrace(skipFrame int) string {
	pc := make([]uintptr, 32)
	n := runtime.Callers(skipFrame, pc)
	pc = pc[:n]
	frames := runtime.CallersFrames(pc)
	msg := make([]string, 0, n)
	for {
		frame, more := frames.Next()
		funcName := frame.Function
		line := frame.Line
		file := frame.File
		msg = append(msg, fmt.Sprintf("\t%s:%d\n\t%s", file, line, funcName))
		if !more {
			break
		}
	}

	return strings.Join(msg, "\n")
}

func (e ERROR) toError(skipFrame int, msgFormat string, args ...interface{}) *errors.Error {
	err := errors.New(ERRORHttpCodeMap[int32(e.Number())], e.String(), fmt.Sprintf(msgFormat, args...))
	innerErr := errors.New(int(err.Code), err.Reason, err.Message).WithMetadata(map[string]string{
		"BizCode":        strconv.Itoa(int(e.Number())),
		"DefaultMessage": ERRORMessageMap[int32(e.Number())],
		"__Stack":        e.stackTrace(skipFrame),
		"__MetaKey":      "__",
	})
	return err.WithCause(innerErr)
}

func (e ERROR) ToError(msgFormat string, args ...interface{}) *errors.Error {
	return e.toError(4, msgFormat, args...)
}

// FromErrorf generate error from err with extra info, if err is nil, mean's everything is fine, return nil
func (e ERROR) FromErrorf(err error, format string, args ...interface{}) *errors.Error {
	if err == nil {
		return nil
	}

	te := e.toError(4, format, args...)
	return te.WithCause(te.Unwrap().(*errors.Error).WithCause(err))
}

// FromError generate error from err with extra info, if err is nil, mean's everything is fine, return nil
func (e ERROR) FromError(err error) *errors.Error {
	if err == nil {
		return nil
	}

	te := e.toError(4, "")
	return te.WithCause(te.Unwrap().(*errors.Error).WithCause(err))
}

// FromOrToError generate error from err with extra info, if err is nil, generate new error
func (e ERROR) FromOrToError(err error) *errors.Error {
	if err == nil {
		return e.toError(4, "")
	}

	te := e.toError(4, "")
	return te.WithCause(te.Unwrap().(*errors.Error).WithCause(err))
}

func (e ERROR) DefaultMessage() string {
	return ERRORMessageMap[int32(e.Number())]
}

func (e ERROR) HttpCode() int {
	return ERRORHttpCodeMap[int32(e.Number())]
}

func IsErrorUnspecified(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_ERROR_UNSPECIFIED.String() && e.Code == 200
}

func ErrorErrorUnspecified(format string, args ...interface{}) *errors.Error {
	return ERROR_ERROR_UNSPECIFIED.toError(4, format, args...)
}

// 参数校验错误
func IsBadRequest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_BAD_REQUEST.String() && e.Code == 400
}

// 参数校验错误
func ErrorBadRequest(format string, args ...interface{}) *errors.Error {
	return ERROR_BAD_REQUEST.toError(4, format, args...)
}

// 未处理错误
func IsUnknown(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_UNKNOWN.String() && e.Code == 404
}

// 未处理错误
func ErrorUnknown(format string, args ...interface{}) *errors.Error {
	return ERROR_UNKNOWN.toError(4, format, args...)
}

// 认证错误
func IsUnauthorized(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_UNAUTHORIZED.String() && e.Code == 401
}

// 认证错误
func ErrorUnauthorized(format string, args ...interface{}) *errors.Error {
	return ERROR_UNAUTHORIZED.toError(4, format, args...)
}

// oh missing
func IsContentMissing(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_CONTENT_MISSING.String() && e.Code == 400
}

// oh missing
func ErrorContentMissing(format string, args ...interface{}) *errors.Error {
	return ERROR_CONTENT_MISSING.toError(4, format, args...)
}

// oh error
func IsContentError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_CONTENT_ERROR.String() && e.Code == 401
}

// oh error
func ErrorContentError(format string, args ...interface{}) *errors.Error {
	return ERROR_CONTENT_ERROR.toError(4, format, args...)
}

// query db error from sql-fx plugin
func IsQueryDest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_QUERY_DEST.String() && e.Code == 500
}

// query db error from sql-fx plugin
func ErrorQueryDest(format string, args ...interface{}) *errors.Error {
	return ERROR_QUERY_DEST.toError(4, format, args...)
}

// query db's injection is not implemented
func IsQueryNotImplement(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_QUERY_NOT_IMPLEMENT.String() && e.Code == 500
}

// query db's injection is not implemented
func ErrorQueryNotImplement(format string, args ...interface{}) *errors.Error {
	return ERROR_QUERY_NOT_IMPLEMENT.toError(4, format, args...)
}

// query args not found
func IsQueryArgsNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_QUERY_ARGS_NOT_FOUND.String() && e.Code == 500
}

// query args not found
func ErrorQueryArgsNotFound(format string, args ...interface{}) *errors.Error {
	return ERROR_QUERY_ARGS_NOT_FOUND.toError(4, format, args...)
}
