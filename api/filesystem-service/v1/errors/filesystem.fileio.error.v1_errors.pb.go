// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package filesystemerrorv1

import (
	fmt "fmt"
	runtime "runtime"
	strconv "strconv"
	strings "strings"

	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

var FILEIO_ERRORMessageMap = map[int32]string{
	0:   "",
	100: "",
	101: "",
	102: "",
	103: "",
}

var FILEIO_ERRORHttpCodeMap = map[int32]int{
	0:   200,
	100: 200,
	101: 200,
	102: 200,
	103: 500,
}

func (e FILEIO_ERROR) stackTrace(skipFrame int) string {
	pc := make([]uintptr, 32)
	n := runtime.Callers(skipFrame, pc)
	pc = pc[:n]
	frames := runtime.CallersFrames(pc)
	msg := make([]string, 0, n)
	for {
		frame, more := frames.Next()
		funcName := frame.Function
		line := frame.Line
		file := frame.File
		msg = append(msg, fmt.Sprintf("\t%s:%d\n\t%s", file, line, funcName))
		if !more {
			break
		}
	}

	return strings.Join(msg, "\n")
}

func (e FILEIO_ERROR) toError(skipFrame int, msgFormat string, args ...interface{}) *errors.Error {
	err := errors.New(FILEIO_ERRORHttpCodeMap[int32(e.Number())], e.String(), fmt.Sprintf(msgFormat, args...))
	innerErr := errors.New(int(err.Code), err.Reason, err.Message).WithMetadata(map[string]string{
		"BizCode":        strconv.Itoa(int(e.Number())),
		"DefaultMessage": FILEIO_ERRORMessageMap[int32(e.Number())],
		"__Stack":        e.stackTrace(skipFrame),
		"__MetaKey":      "__",
	})
	return err.WithCause(innerErr)
}

func (e FILEIO_ERROR) ToError(msgFormat string, args ...interface{}) *errors.Error {
	return e.toError(4, msgFormat, args...)
}

// FromErrorf generate error from err with extra info, if err is nil, mean's everything is fine, return nil
func (e FILEIO_ERROR) FromErrorf(err error, format string, args ...interface{}) *errors.Error {
	if err == nil {
		return nil
	}

	te := e.toError(4, format, args...)
	return te.WithCause(te.Unwrap().(*errors.Error).WithCause(err))
}

// FromError generate error from err with extra info, if err is nil, mean's everything is fine, return nil
func (e FILEIO_ERROR) FromError(err error) *errors.Error {
	if err == nil {
		return nil
	}

	te := e.toError(4, "")
	return te.WithCause(te.Unwrap().(*errors.Error).WithCause(err))
}

// FromOrToError generate error from err with extra info, if err is nil, generate new error
func (e FILEIO_ERROR) FromOrToError(err error) *errors.Error {
	if err == nil {
		return e.toError(4, "")
	}

	te := e.toError(4, "")
	return te.WithCause(te.Unwrap().(*errors.Error).WithCause(err))
}

func (e FILEIO_ERROR) DefaultMessage() string {
	return FILEIO_ERRORMessageMap[int32(e.Number())]
}

func (e FILEIO_ERROR) HttpCode() int {
	return FILEIO_ERRORHttpCodeMap[int32(e.Number())]
}

func IsOk(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == FILEIO_ERROR_OK.String() && e.Code == 200
}

func ErrorOk(format string, args ...interface{}) *errors.Error {
	return FILEIO_ERROR_OK.toError(4, format, args...)
}

func IsObjectNotExist(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == FILEIO_ERROR_OBJECT_NOT_EXIST.String() && e.Code == 200
}

func ErrorObjectNotExist(format string, args ...interface{}) *errors.Error {
	return FILEIO_ERROR_OBJECT_NOT_EXIST.toError(4, format, args...)
}

func IsObjectExist(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == FILEIO_ERROR_OBJECT_EXIST.String() && e.Code == 200
}

func ErrorObjectExist(format string, args ...interface{}) *errors.Error {
	return FILEIO_ERROR_OBJECT_EXIST.toError(4, format, args...)
}

func IsAccessDenied(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == FILEIO_ERROR_ACCESS_DENIED.String() && e.Code == 200
}

func ErrorAccessDenied(format string, args ...interface{}) *errors.Error {
	return FILEIO_ERROR_ACCESS_DENIED.toError(4, format, args...)
}

func IsInternal(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == FILEIO_ERROR_INTERNAL.String() && e.Code == 500
}

func ErrorInternal(format string, args ...interface{}) *errors.Error {
	return FILEIO_ERROR_INTERNAL.toError(4, format, args...)
}
